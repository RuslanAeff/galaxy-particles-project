<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Hand - Interactive Particle Experience</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', sans-serif;
        }

        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #video-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(0, 200, 255, 0.3);
            box-shadow: 0 0 20px rgba(0, 200, 255, 0.2);
            z-index: 100;
            opacity: 0.85;
            transition: opacity 0.3s, transform 0.3s;
        }

        #video-container:hover {
            opacity: 1;
            transform: scale(1.05);
        }

        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader {
            width: 80px;
            height: 80px;
            border: 3px solid transparent;
            border-top-color: #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            position: relative;
        }

        .loader::before {
            content: '';
            position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            bottom: 5px;
            border: 3px solid transparent;
            border-top-color: #a855f7;
            border-radius: 50%;
            animation: spin 0.8s linear infinite reverse;
        }

        .loader::after {
            content: '';
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            bottom: 15px;
            border: 3px solid transparent;
            border-top-color: #fbbf24;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        #loading-text {
            color: #fff;
            margin-top: 30px;
            font-size: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0.7;
        }

        #instructions {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.8);
            font-size: 13px;
            text-align: center;
            z-index: 100;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0, 200, 255, 0.5);
            max-width: 900px;
            line-height: 1.8;
            background: rgba(0, 0, 0, 0.5);
            padding: 12px 20px;
            border-radius: 12px;
            backdrop-filter: blur(5px);
        }

        #hand-status {
            position: fixed;
            bottom: 20px;
            left: 20px;
            padding: 14px 20px;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(0, 200, 255, 0.4);
            border-radius: 16px;
            color: #00d4ff;
            font-size: 13px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 250px;
            backdrop-filter: blur(10px);
        }

        .status-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff4444;
            transition: background 0.3s, box-shadow 0.3s;
        }

        .status-dot.active {
            background: #00ff88;
            box-shadow: 0 0 12px #00ff88;
        }

        .gesture-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
            color: #a855f7;
        }

        .gesture-icon {
            font-size: 24px;
        }

        .shape-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: #fbbf24;
            padding-top: 6px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .shape-name {
            font-weight: bold;
            color: #00d4ff;
        }
    </style>
</head>

<body>
    <div id="loading">
        <div class="loader"></div>
        <div id="loading-text">Sistem Ba≈ülatƒ±lƒ±yor...</div>
    </div>

    <div id="container"></div>

    <div id="video-container">
        <video id="webcam" autoplay playsinline></video>
    </div>

    <div id="instructions">
        üñêÔ∏è <strong>A√ßƒ±k El:</strong> Daƒüƒ±t |
        ‚úä <strong>Yumruk:</strong> Halka |
        üëç <strong>Ba≈üparmak:</strong> Galaksi |
        ‚úåÔ∏è <strong>Peace:</strong> DNA |
        ‚òùÔ∏è <strong>ƒ∞≈üaret:</strong> Vortex |
        ü§ò <strong>Rock:</strong> Kara Delik |
        üëå <strong>OK:</strong> Atom
    </div>

    <div id="hand-status">
        <div class="status-row">
            <div class="status-dot" id="status-dot"></div>
            <span id="status-text">El Bekleniyor...</span>
        </div>
        <div class="gesture-indicator">
            <span class="gesture-icon" id="gesture-icon">üñêÔ∏è</span>
            <span id="gesture-text">Hareket yok</span>
        </div>
        <div class="shape-indicator">
            <span>≈ûekil:</span>
            <span class="shape-name" id="shape-name">Varsayƒ±lan</span>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.min.js"></script>

    <script>
        // ============================================
        // QUANTUM HAND - Multi-Gesture Version
        // 7 Gestures, 7 Unique Shapes
        // ============================================

        // ============================================
        // GESTURE TYPES
        // ============================================
        const GESTURES = {
            NONE: 'none',
            OPEN_HAND: 'open_hand',      // üñêÔ∏è Dispersion
            FIST: 'fist',                // ‚úä Torus
            THUMBS_UP: 'thumbs_up',      // üëç Galaxy
            PEACE: 'peace',              // ‚úåÔ∏è DNA Helix
            POINTING: 'pointing',        // ‚òùÔ∏è Vortex
            ROCK: 'rock',                // ü§ò Black Hole
            OK: 'ok'                     // üëå Atom
        };

        // ============================================
        // KALMAN FILTER
        // ============================================
        class KalmanFilter {
            constructor(processNoise = 0.01, measurementNoise = 0.1, estimatedError = 1) {
                this.Q = processNoise;
                this.R = measurementNoise;
                this.P = estimatedError;
                this.X = 0;
                this.K = 0;
            }

            update(measurement) {
                this.P = this.P + this.Q;
                this.K = this.P / (this.P + this.R);
                this.X = this.X + this.K * (measurement - this.X);
                this.P = (1 - this.K) * this.P;
                return this.X;
            }

            reset(value) {
                this.X = value;
                this.P = 1;
            }
        }

        // ============================================
        // EXPONENTIAL SMOOTHING
        // ============================================
        class ExponentialSmooth {
            constructor(alpha = 0.15) {
                this.alpha = alpha;
                this.value = null;
            }

            update(newValue) {
                if (this.value === null) {
                    this.value = newValue;
                } else {
                    this.value = this.alpha * newValue + (1 - this.alpha) * this.value;
                }
                return this.value;
            }

            reset(value) {
                this.value = value;
            }
        }

        // ============================================
        // MAIN APPLICATION
        // ============================================
        class QuantumHand {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.particles = null;
                this.particleGroup = null;
                this.particleCount = 12000;

                // Shape positions for each gesture
                this.shapePositions = {};
                this.currentLocalPositions = [];
                this.velocities = [];

                // Time tracking
                this.lastTime = performance.now();
                this.deltaTime = 0;
                this.time = 0;

                // Hand detection state
                this.wasHandDetected = false;

                // Stabilization filters
                this.positionFilters = {
                    x: new KalmanFilter(0.005, 0.08, 1),
                    y: new KalmanFilter(0.005, 0.08, 1),
                    z: new KalmanFilter(0.005, 0.15, 1)
                };

                this.positionSmooth = {
                    x: new ExponentialSmooth(0.1),
                    y: new ExponentialSmooth(0.1),
                    z: new ExponentialSmooth(0.08)
                };

                this.rotationFilters = {
                    x: new KalmanFilter(0.001, 0.15, 1),
                    y: new KalmanFilter(0.001, 0.15, 1),
                    z: new KalmanFilter(0.001, 0.12, 1)
                };

                this.rotationSmooth = {
                    x: new ExponentialSmooth(0.05),
                    y: new ExponentialSmooth(0.05),
                    z: new ExponentialSmooth(0.06)
                };

                // Gesture history
                this.gestureHistory = [];
                this.gestureHistorySize = 10;

                // Hand tracking data
                this.handData = {
                    detected: false,
                    rawPosition: { x: 0, y: 0, z: 0 },
                    rawRotation: { x: 0, y: 0, z: 0 },
                    stablePosition: { x: 0, y: 0, z: 0 },
                    stableRotation: { x: 0, y: 0, z: 0 },
                    renderPosition: { x: 0, y: 0, z: 0 },
                    renderRotation: { x: 0, y: 0, z: 0 },
                    lastStableRotation: { x: 0, y: 0, z: 0 },
                    gesture: GESTURES.NONE,
                    velocity: { x: 0, y: 0, z: 0 }
                };

                this.rotationDeadZone = 0.03;

                // Current shape transition
                this.currentGesture = GESTURES.NONE;
                this.targetGesture = GESTURES.NONE;
                this.shapeTransition = 0;

                // Shape scale
                this.shapeScale = 2.0;

                // Color palettes for each gesture
                this.gestureColors = {
                    [GESTURES.OPEN_HAND]: [
                        new THREE.Color(0x00d4ff), new THREE.Color(0x00b4d8),
                        new THREE.Color(0x0077b6), new THREE.Color(0xa855f7)
                    ],
                    [GESTURES.FIST]: [
                        new THREE.Color(0xfbbf24), new THREE.Color(0xf59e0b),
                        new THREE.Color(0xef4444), new THREE.Color(0xf97316)
                    ],
                    [GESTURES.THUMBS_UP]: [
                        new THREE.Color(0x818cf8), new THREE.Color(0xa78bfa),
                        new THREE.Color(0xc4b5fd), new THREE.Color(0xe879f9)
                    ],
                    [GESTURES.PEACE]: [
                        new THREE.Color(0x34d399), new THREE.Color(0x10b981),
                        new THREE.Color(0x06b6d4), new THREE.Color(0x22d3ee)
                    ],
                    [GESTURES.POINTING]: [
                        new THREE.Color(0xf472b6), new THREE.Color(0xec4899),
                        new THREE.Color(0xdb2777), new THREE.Color(0xbe185d)
                    ],
                    [GESTURES.ROCK]: [
                        new THREE.Color(0x1f2937), new THREE.Color(0x374151),
                        new THREE.Color(0xfbbf24), new THREE.Color(0xf97316)
                    ],
                    [GESTURES.OK]: [
                        new THREE.Color(0x60a5fa), new THREE.Color(0x3b82f6),
                        new THREE.Color(0x22d3ee), new THREE.Color(0x06b6d4)
                    ],
                    [GESTURES.NONE]: [
                        new THREE.Color(0x00d4ff), new THREE.Color(0xa855f7),
                        new THREE.Color(0x7c3aed), new THREE.Color(0x06b6d4)
                    ]
                };

                this.init();
            }

            async init() {
                this.updateLoadingText('Three.js ba≈ülatƒ±lƒ±yor...');
                await this.initThreeJS();

                this.updateLoadingText('≈ûekiller olu≈üturuluyor...');
                await this.generateAllShapes();

                this.updateLoadingText('Par√ßacƒ±k sistemi olu≈üturuluyor...');
                await this.createParticles();

                this.updateLoadingText('Kamera a√ßƒ±lƒ±yor...');
                await this.initWebcam();

                this.updateLoadingText('El takibi ba≈ülatƒ±lƒ±yor...');
                await this.initHandTracking();

                this.hideLoading();
                this.animate();
            }

            updateLoadingText(text) {
                document.getElementById('loading-text').textContent = text;
            }

            hideLoading() {
                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                }, 500);
            }

            // ============================================
            // SHAPE GENERATORS
            // ============================================

            generateAllShapes() {
                return new Promise((resolve) => {
                    const count = this.particleCount;
                    const scale = this.shapeScale;

                    // Generate all shape positions
                    this.shapePositions[GESTURES.NONE] = this.generateTorus(count, scale);
                    this.shapePositions[GESTURES.OPEN_HAND] = this.generateDispersion(count, scale * 2.5);
                    this.shapePositions[GESTURES.FIST] = this.generateTorus(count, scale);
                    this.shapePositions[GESTURES.THUMBS_UP] = this.generateGalaxy(count, scale);
                    this.shapePositions[GESTURES.PEACE] = this.generateDNA(count, scale);
                    this.shapePositions[GESTURES.POINTING] = this.generateVortex(count, scale);
                    this.shapePositions[GESTURES.ROCK] = this.generateBlackHole(count, scale);
                    this.shapePositions[GESTURES.OK] = this.generateAtom(count, scale);

                    resolve();
                });
            }

            // üåå GALAXY - Spiral arms like Milky Way
            generateGalaxy(count, scale) {
                const positions = [];
                const armCount = 4;
                const spiralTightness = 0.5;

                for (let i = 0; i < count; i++) {
                    const arm = i % armCount;
                    const armOffset = (arm / armCount) * Math.PI * 2;

                    // Distance from center
                    const t = Math.pow(Math.random(), 0.5);
                    const distance = t * scale * 1.8;

                    // Spiral angle
                    const spiralAngle = distance * spiralTightness + armOffset;

                    // Add some scatter
                    const scatter = (1 - t * 0.7) * 0.4 * scale;
                    const scatterX = (Math.random() - 0.5) * scatter;
                    const scatterY = (Math.random() - 0.5) * scatter * 0.15;
                    const scatterZ = (Math.random() - 0.5) * scatter;

                    // Bulge in center (more particles, more height)
                    const bulgeFactor = Math.exp(-distance * 1.5);
                    const bulgeHeight = bulgeFactor * (Math.random() - 0.5) * scale * 0.4;

                    positions.push({
                        x: Math.cos(spiralAngle) * distance + scatterX,
                        y: bulgeHeight + scatterY,
                        z: Math.sin(spiralAngle) * distance + scatterZ
                    });
                }
                return positions;
            }

            // üß¨ DNA - Double helix
            generateDNA(count, scale) {
                const positions = [];
                const helixRadius = scale * 0.4;
                const helixHeight = scale * 3;
                const turns = 4;

                for (let i = 0; i < count; i++) {
                    const t = i / count;
                    const angle = t * Math.PI * 2 * turns;
                    const y = (t - 0.5) * helixHeight;

                    // Determine which strand (0 or 1) or connecting bar
                    const strand = i % 10;

                    if (strand < 4) {
                        // Strand 1
                        positions.push({
                            x: Math.cos(angle) * helixRadius + (Math.random() - 0.5) * 0.1,
                            y: y + (Math.random() - 0.5) * 0.1,
                            z: Math.sin(angle) * helixRadius + (Math.random() - 0.5) * 0.1
                        });
                    } else if (strand < 8) {
                        // Strand 2 (opposite phase)
                        positions.push({
                            x: Math.cos(angle + Math.PI) * helixRadius + (Math.random() - 0.5) * 0.1,
                            y: y + (Math.random() - 0.5) * 0.1,
                            z: Math.sin(angle + Math.PI) * helixRadius + (Math.random() - 0.5) * 0.1
                        });
                    } else {
                        // Connecting bars (base pairs)
                        const barT = Math.random();
                        const x1 = Math.cos(angle) * helixRadius;
                        const z1 = Math.sin(angle) * helixRadius;
                        const x2 = Math.cos(angle + Math.PI) * helixRadius;
                        const z2 = Math.sin(angle + Math.PI) * helixRadius;

                        positions.push({
                            x: x1 + (x2 - x1) * barT,
                            y: y,
                            z: z1 + (z2 - z1) * barT
                        });
                    }
                }
                return positions;
            }

            // üåÄ VORTEX - Upward spiral tornado
            generateVortex(count, scale) {
                const positions = [];
                const maxRadius = scale * 1.2;
                const height = scale * 3;

                for (let i = 0; i < count; i++) {
                    const t = i / count;
                    const y = (t - 0.5) * height;

                    // Radius decreases as we go up (tornado shape)
                    const heightFactor = 1 - t;
                    const radius = maxRadius * (0.1 + heightFactor * 0.9);

                    // Spiral angle increases with height
                    const spiralSpeed = 3 + t * 5;
                    const angle = t * Math.PI * 2 * spiralSpeed + Math.random() * 0.5;

                    // Add turbulence
                    const turbulence = (Math.random() - 0.5) * radius * 0.3;

                    positions.push({
                        x: Math.cos(angle) * (radius + turbulence),
                        y: y,
                        z: Math.sin(angle) * (radius + turbulence)
                    });
                }
                return positions;
            }

            // ‚ö´ BLACK HOLE - Event horizon with accretion disk
            generateBlackHole(count, scale) {
                const positions = [];
                const diskRadius = scale * 1.5;
                const holeRadius = scale * 0.3;

                for (let i = 0; i < count; i++) {
                    const t = i / count;

                    if (t < 0.15) {
                        // Event horizon - dense dark center
                        const r = Math.random() * holeRadius;
                        const angle = Math.random() * Math.PI * 2;
                        positions.push({
                            x: Math.cos(angle) * r,
                            y: (Math.random() - 0.5) * holeRadius * 0.5,
                            z: Math.sin(angle) * r
                        });
                    } else {
                        // Accretion disk - swirling matter
                        const distFromCenter = holeRadius + Math.pow(Math.random(), 0.5) * (diskRadius - holeRadius);
                        const angle = Math.random() * Math.PI * 2;

                        // Disk is denser toward center, thinner
                        const thickness = 0.05 * scale * (1 - (distFromCenter - holeRadius) / (diskRadius - holeRadius));

                        // Add spiral structure
                        const spiralOffset = distFromCenter * 0.3;

                        positions.push({
                            x: Math.cos(angle + spiralOffset) * distFromCenter,
                            y: (Math.random() - 0.5) * thickness,
                            z: Math.sin(angle + spiralOffset) * distFromCenter
                        });
                    }
                }
                return positions;
            }

            // ‚öõÔ∏è ATOM - Nucleus with orbiting electrons
            generateAtom(count, scale) {
                const positions = [];
                const nucleusRadius = scale * 0.25;
                const orbitRadius = scale * 1.2;
                const orbitCount = 3;

                for (let i = 0; i < count; i++) {
                    const t = i / count;

                    if (t < 0.2) {
                        // Nucleus (protons and neutrons)
                        const phi = Math.random() * Math.PI * 2;
                        const theta = Math.acos(2 * Math.random() - 1);
                        const r = Math.pow(Math.random(), 0.33) * nucleusRadius;

                        positions.push({
                            x: r * Math.sin(theta) * Math.cos(phi),
                            y: r * Math.sin(theta) * Math.sin(phi),
                            z: r * Math.cos(theta)
                        });
                    } else {
                        // Electron orbits
                        const orbit = Math.floor((i * orbitCount) / count);
                        const orbitAngle = orbit * (Math.PI / orbitCount);

                        const angleInOrbit = Math.random() * Math.PI * 2;
                        const r = orbitRadius * (0.8 + Math.random() * 0.4);

                        // Rotate orbit plane
                        const x = Math.cos(angleInOrbit) * r;
                        const y = Math.sin(angleInOrbit) * r * Math.cos(orbitAngle);
                        const z = Math.sin(angleInOrbit) * r * Math.sin(orbitAngle);

                        // Add scatter
                        positions.push({
                            x: x + (Math.random() - 0.5) * 0.1,
                            y: y + (Math.random() - 0.5) * 0.1,
                            z: z + (Math.random() - 0.5) * 0.1
                        });
                    }
                }
                return positions;
            }

            // ‚≠ï TORUS
            generateTorus(count, scale) {
                const positions = [];
                const torusRadius = scale * 0.8;
                const tubeRadius = scale * 0.25;

                for (let i = 0; i < count; i++) {
                    const u = (i / count) * Math.PI * 2 + Math.random() * 0.1;
                    const v = Math.random() * Math.PI * 2;
                    const r = tubeRadius + (Math.random() - 0.5) * 0.1;

                    positions.push({
                        x: (torusRadius + r * Math.cos(v)) * Math.cos(u),
                        y: (torusRadius + r * Math.cos(v)) * Math.sin(u),
                        z: r * Math.sin(v)
                    });
                }
                return positions;
            }

            // üí´ DISPERSION
            generateDispersion(count, scale) {
                const positions = [];
                for (let i = 0; i < count; i++) {
                    const phi = Math.random() * Math.PI * 2;
                    const theta = Math.acos(2 * Math.random() - 1);
                    const r = scale * (0.3 + Math.random() * 0.7);

                    positions.push({
                        x: r * Math.sin(theta) * Math.cos(phi),
                        y: r * Math.sin(theta) * Math.sin(phi),
                        z: r * Math.cos(theta)
                    });
                }
                return positions;
            }

            // ============================================
            // THREE.JS SETUP
            // ============================================

            initThreeJS() {
                return new Promise((resolve) => {
                    this.scene = new THREE.Scene();

                    this.camera = new THREE.PerspectiveCamera(
                        75,
                        window.innerWidth / window.innerHeight,
                        0.1,
                        1000
                    );
                    this.camera.position.z = 10;

                    this.renderer = new THREE.WebGLRenderer({
                        antialias: true,
                        alpha: true,
                        powerPreference: "high-performance"
                    });
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    this.renderer.setClearColor(0x000000, 1);
                    document.getElementById('container').appendChild(this.renderer.domElement);

                    this.particleGroup = new THREE.Group();
                    this.scene.add(this.particleGroup);

                    window.addEventListener('resize', () => this.onWindowResize());

                    resolve();
                });
            }

            createParticles() {
                return new Promise((resolve) => {
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(this.particleCount * 3);
                    const colors = new Float32Array(this.particleCount * 3);
                    const sizes = new Float32Array(this.particleCount);

                    const defaultPositions = this.shapePositions[GESTURES.NONE];

                    for (let i = 0; i < this.particleCount; i++) {
                        const pos = defaultPositions[i];

                        positions[i * 3] = pos.x;
                        positions[i * 3 + 1] = pos.y;
                        positions[i * 3 + 2] = pos.z;

                        this.currentLocalPositions.push({ ...pos });
                        this.velocities.push({ x: 0, y: 0, z: 0 });

                        const color = this.gestureColors[GESTURES.NONE][i % 4];
                        colors[i * 3] = color.r;
                        colors[i * 3 + 1] = color.g;
                        colors[i * 3 + 2] = color.b;

                        sizes[i] = Math.random() * 0.06 + 0.04;
                    }

                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                    const material = new THREE.ShaderMaterial({
                        uniforms: {
                            time: { value: 0 }
                        },
                        vertexShader: `
                            attribute float size;
                            varying vec3 vColor;
                            uniform float time;
                            
                            void main() {
                                vColor = color;
                                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                                
                                float pulse = 1.0 + 0.1 * sin(time * 2.0 + position.x * 1.5);
                                gl_PointSize = size * pulse * (400.0 / -mvPosition.z);
                                
                                gl_Position = projectionMatrix * mvPosition;
                            }
                        `,
                        fragmentShader: `
                            varying vec3 vColor;
                            
                            void main() {
                                vec2 center = gl_PointCoord - vec2(0.5);
                                float dist = length(center);
                                
                                if (dist > 0.5) discard;
                                
                                float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                                float glow = exp(-dist * 2.0);
                                
                                vec3 finalColor = vColor * (1.0 + glow * 1.5);
                                gl_FragColor = vec4(finalColor, alpha * 0.95);
                            }
                        `,
                        transparent: true,
                        vertexColors: true,
                        blending: THREE.AdditiveBlending,
                        depthWrite: false
                    });

                    this.particles = new THREE.Points(geometry, material);
                    this.particleGroup.add(this.particles);

                    resolve();
                });
            }

            // ============================================
            // WEBCAM & HAND TRACKING
            // ============================================

            async initWebcam() {
                const video = document.getElementById('webcam');

                // Detect if mobile
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                // More flexible camera constraints for mobile
                const constraints = {
                    video: {
                        width: { ideal: isMobile ? 480 : 640 },
                        height: { ideal: isMobile ? 360 : 480 },
                        facingMode: 'user'
                    },
                    audio: false
                };

                try {
                    // Request camera permission
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    video.srcObject = stream;

                    // Mobile-specific attributes
                    video.setAttribute('playsinline', 'true');
                    video.setAttribute('webkit-playsinline', 'true');
                    video.muted = true;

                    return new Promise((resolve, reject) => {
                        video.onloadedmetadata = () => {
                            video.play()
                                .then(() => {
                                    console.log('üìπ Camera started successfully');
                                    resolve();
                                })
                                .catch(err => {
                                    console.error('Video play error:', err);
                                    // Try again with user interaction
                                    document.body.addEventListener('click', () => video.play(), { once: true });
                                    resolve();
                                });
                        };

                        video.onerror = (err) => {
                            console.error('Video error:', err);
                            reject(err);
                        };

                        // Timeout for slow mobile connections
                        setTimeout(() => {
                            if (video.readyState < 2) {
                                console.warn('Video loading timeout, continuing anyway...');
                                resolve();
                            }
                        }, 10000);
                    });
                } catch (error) {
                    console.error('Webcam error:', error);

                    // Show user-friendly error message
                    const statusText = document.getElementById('status-text');
                    if (statusText) {
                        if (error.name === 'NotAllowedError') {
                            statusText.textContent = 'Kamera izni verilmedi!';
                        } else if (error.name === 'NotFoundError') {
                            statusText.textContent = 'Kamera bulunamadƒ±!';
                        } else if (error.name === 'NotReadableError') {
                            statusText.textContent = 'Kamera ba≈üka uygulama tarafƒ±ndan kullanƒ±lƒ±yor!';
                        } else {
                            statusText.textContent = 'Kamera hatasƒ±: ' + error.message;
                        }
                    }

                    document.getElementById('video-container').style.display = 'none';
                }
            }

            async initHandTracking() {
                const video = document.getElementById('webcam');
                if (!video.srcObject) {
                    console.error('No video stream available for hand tracking');
                    return;
                }

                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                try {
                    this.hands = new Hands({
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
                    });

                    // Lower complexity for mobile performance
                    this.hands.setOptions({
                        maxNumHands: 1,
                        modelComplexity: isMobile ? 0 : 1, // 0 = lite model for mobile
                        minDetectionConfidence: isMobile ? 0.6 : 0.7,
                        minTrackingConfidence: isMobile ? 0.5 : 0.6
                    });

                    this.hands.onResults((results) => this.onHandResults(results));

                    // Use actual video dimensions
                    const videoWidth = video.videoWidth || (isMobile ? 480 : 640);
                    const videoHeight = video.videoHeight || (isMobile ? 360 : 480);

                    const camera = new Camera(video, {
                        onFrame: async () => {
                            try {
                                await this.hands.send({ image: video });
                            } catch (e) {
                                // Silently handle frame errors
                            }
                        },
                        width: videoWidth,
                        height: videoHeight
                    });

                    await camera.start();
                    console.log('üñêÔ∏è Hand tracking started successfully');

                } catch (error) {
                    console.error('Hand tracking init error:', error);
                    const statusText = document.getElementById('status-text');
                    if (statusText) {
                        statusText.textContent = 'El takibi ba≈ülatƒ±lamadƒ±!';
                    }
                }
            }

            onHandResults(results) {
                const statusDot = document.getElementById('status-dot');
                const statusText = document.getElementById('status-text');
                const gestureIcon = document.getElementById('gesture-icon');
                const gestureText = document.getElementById('gesture-text');
                const shapeName = document.getElementById('shape-name');

                const prevPosition = { ...this.handData.rawPosition };

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];

                    this.handData.detected = true;
                    statusDot.classList.add('active');
                    statusText.textContent = 'El Algƒ±landƒ±';

                    // Calculate hand center
                    const wrist = landmarks[0];
                    const indexMcp = landmarks[5];
                    const middleMcp = landmarks[9];
                    const ringMcp = landmarks[13];
                    const pinkyMcp = landmarks[17];

                    const centerX = (wrist.x + indexMcp.x + middleMcp.x + ringMcp.x + pinkyMcp.x) / 5;
                    const centerY = (wrist.y + indexMcp.y + middleMcp.y + ringMcp.y + pinkyMcp.y) / 5;
                    const centerZ = (wrist.z + indexMcp.z + middleMcp.z + ringMcp.z + pinkyMcp.z) / 5;

                    this.handData.rawPosition = {
                        x: (1 - centerX) * 14 - 7,
                        y: -(centerY * 10 - 5),
                        z: -centerZ * 5
                    };

                    // Reset filters when hand first appears
                    if (!this.wasHandDetected) {
                        this.wasHandDetected = true;
                        this.positionFilters.x.reset(this.handData.rawPosition.x);
                        this.positionFilters.y.reset(this.handData.rawPosition.y);
                        this.positionFilters.z.reset(this.handData.rawPosition.z);
                        this.positionSmooth.x.reset(this.handData.rawPosition.x);
                        this.positionSmooth.y.reset(this.handData.rawPosition.y);
                        this.positionSmooth.z.reset(this.handData.rawPosition.z);
                    }

                    // Velocity
                    this.handData.velocity = {
                        x: this.handData.rawPosition.x - prevPosition.x,
                        y: this.handData.rawPosition.y - prevPosition.y,
                        z: this.handData.rawPosition.z - prevPosition.z
                    };

                    // Calculate rotation
                    this.calculateRawRotation(landmarks);

                    // Apply filters
                    this.handData.stablePosition.x = this.positionFilters.x.update(this.handData.rawPosition.x);
                    this.handData.stablePosition.y = this.positionFilters.y.update(this.handData.rawPosition.y);
                    this.handData.stablePosition.z = this.positionFilters.z.update(this.handData.rawPosition.z);

                    this.handData.stableRotation.x = this.rotationFilters.x.update(this.handData.rawRotation.x);
                    this.handData.stableRotation.y = this.rotationFilters.y.update(this.handData.rawRotation.y);
                    this.handData.stableRotation.z = this.rotationFilters.z.update(this.handData.rawRotation.z);

                    // Detect gesture
                    const gesture = this.detectGesture(landmarks);
                    this.handData.gesture = gesture;
                    this.targetGesture = gesture;

                    // Update UI
                    this.updateGestureUI(gesture, gestureIcon, gestureText, shapeName);

                } else {
                    this.handData.detected = false;
                    this.wasHandDetected = false;
                    this.targetGesture = GESTURES.NONE;
                    statusDot.classList.remove('active');
                    statusText.textContent = 'El Bekleniyor...';
                    gestureIcon.textContent = 'üñêÔ∏è';
                    gestureText.textContent = 'Hareket yok';
                    shapeName.textContent = 'Varsayƒ±lan';
                }
            }

            updateGestureUI(gesture, gestureIcon, gestureText, shapeName) {
                const gestureInfo = {
                    [GESTURES.OPEN_HAND]: { icon: 'üñêÔ∏è', text: 'A√ßƒ±k El', shape: 'üí´ Daƒüƒ±lma' },
                    [GESTURES.FIST]: { icon: '‚úä', text: 'Yumruk', shape: '‚≠ï Halka' },
                    [GESTURES.THUMBS_UP]: { icon: 'üëç', text: 'Ba≈üparmak', shape: 'üåå Galaksi' },
                    [GESTURES.PEACE]: { icon: '‚úåÔ∏è', text: 'Peace', shape: 'üß¨ DNA' },
                    [GESTURES.POINTING]: { icon: '‚òùÔ∏è', text: 'ƒ∞≈üaret', shape: 'üåÄ Vortex' },
                    [GESTURES.ROCK]: { icon: 'ü§ò', text: 'Rock', shape: '‚ö´ Kara Delik' },
                    [GESTURES.OK]: { icon: 'üëå', text: 'OK', shape: '‚öõÔ∏è Atom' },
                    [GESTURES.NONE]: { icon: 'üñêÔ∏è', text: 'Belirsiz', shape: 'Varsayƒ±lan' }
                };

                const info = gestureInfo[gesture] || gestureInfo[GESTURES.NONE];
                gestureIcon.textContent = info.icon;
                gestureText.textContent = info.text;
                shapeName.textContent = info.shape;
            }

            calculateRawRotation(landmarks) {
                const wrist = landmarks[0];
                const thumbCmc = landmarks[1];
                const indexMcp = landmarks[5];
                const middleMcp = landmarks[9];
                const ringMcp = landmarks[13];
                const pinkyMcp = landmarks[17];

                // Z rotation (roll)
                const dx1 = pinkyMcp.x - indexMcp.x;
                const dy1 = pinkyMcp.y - indexMcp.y;
                const roll1 = Math.atan2(dy1, dx1);

                const dx2 = ringMcp.x - middleMcp.x;
                const dy2 = ringMcp.y - middleMcp.y;
                const roll2 = Math.atan2(dy2, dx2);

                const dx3 = pinkyMcp.x - thumbCmc.x;
                const dy3 = pinkyMcp.y - thumbCmc.y;
                const roll3 = Math.atan2(dy3, dx3);

                const rolls = [roll1, roll2, roll3];
                const weights = [0.5, 0.25, 0.25];

                let sinSum = 0, cosSum = 0;
                for (let i = 0; i < rolls.length; i++) {
                    sinSum += Math.sin(rolls[i]) * weights[i];
                    cosSum += Math.cos(rolls[i]) * weights[i];
                }
                const rollAngle = Math.atan2(sinSum, cosSum);

                const handDirX = middleMcp.x - wrist.x;
                const handDirY = middleMcp.y - wrist.y;
                const handLength = Math.sqrt(handDirX * handDirX + handDirY * handDirY) + 0.001;
                const pitchAngle = Math.atan2(handDirY, handLength);

                const depthDiff = pinkyMcp.z - indexMcp.z;
                const handWidth = Math.sqrt(dx1 * dx1 + dy1 * dy1) + 0.001;
                const yawAngle = Math.atan2(depthDiff, handWidth);

                const prevRot = this.handData.rawRotation;
                const blend = 0.3;

                const newRotX = prevRot.x * (1 - blend) + (pitchAngle * 0.5) * blend;
                const newRotY = prevRot.y * (1 - blend) + (-yawAngle * 0.3) * blend;
                const newRotZ = prevRot.z * (1 - blend) + (-rollAngle * 0.7) * blend;

                const lastRot = this.handData.lastStableRotation;
                const deadZone = this.rotationDeadZone;

                if (Math.abs(newRotX - lastRot.x) > deadZone ||
                    Math.abs(newRotY - lastRot.y) > deadZone ||
                    Math.abs(newRotZ - lastRot.z) > deadZone) {
                    this.handData.rawRotation = { x: newRotX, y: newRotY, z: newRotZ };
                    this.handData.lastStableRotation = { x: newRotX, y: newRotY, z: newRotZ };
                }
            }

            // ============================================
            // GESTURE DETECTION
            // ============================================

            detectGesture(landmarks) {
                const dominated = this.getFingerStates(landmarks);

                // Add to history for stability
                this.gestureHistory.push(dominated);
                if (this.gestureHistory.length > this.gestureHistorySize) {
                    this.gestureHistory.shift();
                }

                // Count most common gesture in history
                const gestureCounts = {};
                for (const g of this.gestureHistory) {
                    gestureCounts[g] = (gestureCounts[g] || 0) + 1;
                }

                let mostCommon = GESTURES.NONE;
                let maxCount = 0;
                for (const [gesture, count] of Object.entries(gestureCounts)) {
                    if (count > maxCount) {
                        maxCount = count;
                        mostCommon = gesture;
                    }
                }

                // Only change if confident (more than 75% of history for accuracy)
                if (maxCount >= this.gestureHistorySize * 0.75) {
                    return mostCommon;
                }

                return this.handData.gesture; // Keep previous
            }

            getFingerStates(landmarks) {
                // Finger tip and base indices
                const tips = [4, 8, 12, 16, 20];
                const pips = [3, 6, 10, 14, 18];
                const mcps = [2, 5, 9, 13, 17];

                const wrist = landmarks[0];
                const thumbTip = landmarks[4];
                const thumbIp = landmarks[3];
                const thumbMcp = landmarks[2];
                const indexTip = landmarks[8];
                const indexPip = landmarks[6];
                const indexMcp = landmarks[5];
                const middleTip = landmarks[12];
                const middlePip = landmarks[10];
                const ringTip = landmarks[16];
                const ringPip = landmarks[14];
                const pinkyTip = landmarks[20];
                const pinkyPip = landmarks[18];

                // Calculate finger extensions with stricter thresholds
                const thumbExtension = this.distance(thumbTip, wrist) / this.distance(thumbMcp, wrist);
                const indexExtension = this.distance(indexTip, wrist) / this.distance(indexPip, wrist);
                const middleExtension = this.distance(middleTip, wrist) / this.distance(middlePip, wrist);
                const ringExtension = this.distance(ringTip, wrist) / this.distance(ringPip, wrist);
                const pinkyExtension = this.distance(pinkyTip, wrist) / this.distance(pinkyPip, wrist);

                // Stricter thresholds for better accuracy
                const extendedThreshold = 1.15;
                const curledThreshold = 0.95;

                const isThumbExtended = thumbExtension > 1.25;
                const isIndexExtended = indexExtension > extendedThreshold;
                const isMiddleExtended = middleExtension > extendedThreshold;
                const isRingExtended = ringExtension > extendedThreshold;
                const isPinkyExtended = pinkyExtension > extendedThreshold;

                const isIndexCurled = indexExtension < curledThreshold;
                const isMiddleCurled = middleExtension < curledThreshold;
                const isRingCurled = ringExtension < curledThreshold;
                const isPinkyCurled = pinkyExtension < curledThreshold;

                // Thumb is up (thumb extended AND above wrist, others curled)
                const isThumbUp = isThumbExtended &&
                    isIndexCurled && isMiddleCurled && isRingCurled && isPinkyCurled &&
                    thumbTip.y < wrist.y;

                // Peace sign (index and middle extended, ring and pinky curled)
                const isPeace = isIndexExtended && isMiddleExtended &&
                    isRingCurled && isPinkyCurled && !isThumbExtended;

                // Pointing (ONLY index extended, all others curled)
                const isPointing = isIndexExtended &&
                    isMiddleCurled && isRingCurled && isPinkyCurled && !isThumbExtended;

                // Rock sign (index and pinky extended, middle and ring MUST be curled)
                const isRock = isIndexExtended && isPinkyExtended &&
                    isMiddleCurled && isRingCurled;

                // OK sign (thumb and index tips very close, others extended)
                const thumbIndexDist = this.distance(thumbTip, indexTip);
                const palmSize = this.distance(wrist, landmarks[9]);
                const isOK = thumbIndexDist < palmSize * 0.25 &&
                    isMiddleExtended && isRingExtended && isPinkyExtended;

                // Fist (all fingers curled)
                const isFist = !isThumbExtended && !isIndexExtended && !isMiddleExtended &&
                    !isRingExtended && !isPinkyExtended;

                // Open hand (all fingers extended)
                const isOpenHand = isIndexExtended && isMiddleExtended &&
                    isRingExtended && isPinkyExtended;

                // Determine gesture
                if (isThumbUp) return GESTURES.THUMBS_UP;
                if (isOK) return GESTURES.OK;
                if (isRock) return GESTURES.ROCK;
                if (isPeace) return GESTURES.PEACE;
                if (isPointing && !isThumbExtended) return GESTURES.POINTING;
                if (isFist) return GESTURES.FIST;
                if (isOpenHand) return GESTURES.OPEN_HAND;

                return GESTURES.NONE;
            }

            distance(p1, p2) {
                return Math.sqrt(
                    Math.pow(p1.x - p2.x, 2) +
                    Math.pow(p1.y - p2.y, 2) +
                    Math.pow(p1.z - p2.z, 2)
                );
            }

            // ============================================
            // PARTICLE UPDATES
            // ============================================

            updateParticles() {
                const positions = this.particles.geometry.attributes.position.array;
                const colors = this.particles.geometry.attributes.color.array;
                const hand = this.handData;

                const lerpFactor = 1 - Math.pow(0.001, this.deltaTime);

                // Smooth gesture transition
                if (this.currentGesture !== this.targetGesture) {
                    this.shapeTransition += this.deltaTime * 2;
                    if (this.shapeTransition >= 1) {
                        this.currentGesture = this.targetGesture;
                        this.shapeTransition = 0;
                    }
                }

                // Get target positions for current and target gestures
                const currentPositions = this.shapePositions[this.currentGesture] || this.shapePositions[GESTURES.NONE];
                const targetPositions = this.shapePositions[this.targetGesture] || this.shapePositions[GESTURES.NONE];

                // Get colors
                const currentColors = this.gestureColors[this.currentGesture] || this.gestureColors[GESTURES.NONE];
                const targetColors = this.gestureColors[this.targetGesture] || this.gestureColors[GESTURES.NONE];

                // Update group position/rotation
                if (hand.detected) {
                    hand.renderPosition.x = this.positionSmooth.x.update(hand.stablePosition.x);
                    hand.renderPosition.y = this.positionSmooth.y.update(hand.stablePosition.y);
                    hand.renderPosition.z = this.positionSmooth.z.update(hand.stablePosition.z);

                    hand.renderRotation.x = this.rotationSmooth.x.update(hand.stableRotation.x);
                    hand.renderRotation.y = this.rotationSmooth.y.update(hand.stableRotation.y);
                    hand.renderRotation.z = this.rotationSmooth.z.update(hand.stableRotation.z);

                    this.particleGroup.position.x += (hand.renderPosition.x - this.particleGroup.position.x) * lerpFactor * 4;
                    this.particleGroup.position.y += (hand.renderPosition.y - this.particleGroup.position.y) * lerpFactor * 4;
                    this.particleGroup.position.z += (hand.renderPosition.z - this.particleGroup.position.z) * lerpFactor * 3;

                    this.particleGroup.rotation.x += (hand.renderRotation.x - this.particleGroup.rotation.x) * lerpFactor * 3;
                    this.particleGroup.rotation.y += (hand.renderRotation.y - this.particleGroup.rotation.y) * lerpFactor * 3;
                    this.particleGroup.rotation.z += (hand.renderRotation.z - this.particleGroup.rotation.z) * lerpFactor * 3;
                } else {
                    this.particleGroup.position.x *= (1 - lerpFactor * 2);
                    this.particleGroup.position.y *= (1 - lerpFactor * 2);
                    this.particleGroup.position.z *= (1 - lerpFactor * 2);

                    this.particleGroup.rotation.x *= (1 - lerpFactor * 1.5);
                    this.particleGroup.rotation.y *= (1 - lerpFactor * 1.5);
                    this.particleGroup.rotation.z *= (1 - lerpFactor * 1.5);
                }

                // Update individual particles
                const t = this.shapeTransition;

                // ============================================
                // SHAPE-SPECIFIC ROTATION ANIMATION
                // Each shape has its own rotation characteristics
                // ============================================
                const gesture = this.currentGesture;
                let shapeRotationSpeed = 0;
                let shapeRotationAxis = 'y'; // Which axis to rotate around

                if (gesture === GESTURES.THUMBS_UP) {
                    // Galaxy - slow majestic spiral rotation
                    shapeRotationSpeed = 0.15;
                    shapeRotationAxis = 'y';
                } else if (gesture === GESTURES.PEACE) {
                    // DNA - medium rotation around vertical axis
                    shapeRotationSpeed = 0.4;
                    shapeRotationAxis = 'y';
                } else if (gesture === GESTURES.POINTING) {
                    // Vortex - VERY FAST rotation (tornado!)
                    shapeRotationSpeed = 2.5;
                    shapeRotationAxis = 'y';
                } else if (gesture === GESTURES.ROCK) {
                    // Black Hole - medium accretion disk rotation
                    shapeRotationSpeed = 0.6;
                    shapeRotationAxis = 'z';
                } else if (gesture === GESTURES.OK) {
                    // Atom - fast electron orbit
                    shapeRotationSpeed = 0.8;
                    shapeRotationAxis = 'multi'; // All axes
                }

                for (let i = 0; i < this.particleCount; i++) {
                    const current = this.currentLocalPositions[i];
                    const velocity = this.velocities[i];

                    // Interpolate between shapes
                    const currentPos = currentPositions[i];
                    const targetPos = targetPositions[i];

                    let targetX = currentPos.x * (1 - t) + targetPos.x * t;
                    let targetY = currentPos.y * (1 - t) + targetPos.y * t;
                    let targetZ = currentPos.z * (1 - t) + targetPos.z * t;

                    // Apply shape-specific rotation to target positions
                    if (shapeRotationSpeed > 0) {
                        const angle = this.time * shapeRotationSpeed;
                        const cosA = Math.cos(angle);
                        const sinA = Math.sin(angle);

                        if (shapeRotationAxis === 'y') {
                            // Rotate around Y axis
                            const newX = targetX * cosA - targetZ * sinA;
                            const newZ = targetX * sinA + targetZ * cosA;
                            targetX = newX;
                            targetZ = newZ;
                        } else if (shapeRotationAxis === 'z') {
                            // Rotate around Z axis
                            const newX = targetX * cosA - targetY * sinA;
                            const newY = targetX * sinA + targetY * cosA;
                            targetX = newX;
                            targetY = newY;
                        } else if (shapeRotationAxis === 'multi') {
                            // Multi-axis rotation for atom
                            const orbitIndex = i % 3;
                            const orbitAngle = angle + orbitIndex * Math.PI * 2 / 3;
                            const cosO = Math.cos(orbitAngle);
                            const sinO = Math.sin(orbitAngle);

                            if (orbitIndex === 0) {
                                const newX = targetX * cosO - targetZ * sinO;
                                const newZ = targetX * sinO + targetZ * cosO;
                                targetX = newX;
                                targetZ = newZ;
                            } else if (orbitIndex === 1) {
                                const newY = targetY * cosO - targetZ * sinO;
                                const newZ = targetY * sinO + targetZ * cosO;
                                targetY = newY;
                                targetZ = newZ;
                            } else {
                                const newX = targetX * cosO - targetY * sinO;
                                const newY = targetX * sinO + targetY * cosO;
                                targetX = newX;
                                targetY = newY;
                            }
                        }
                    }

                    // Spring physics
                    velocity.x += (targetX - current.x) * 0.1;
                    velocity.y += (targetY - current.y) * 0.1;
                    velocity.z += (targetZ - current.z) * 0.1;

                    velocity.x *= 0.85;
                    velocity.y *= 0.85;
                    velocity.z *= 0.85;

                    current.x += velocity.x;
                    current.y += velocity.y;
                    current.z += velocity.z;

                    positions[i * 3] = current.x;
                    positions[i * 3 + 1] = current.y;
                    positions[i * 3 + 2] = current.z;

                    // Interpolate colors
                    const currentColor = currentColors[i % currentColors.length];
                    const targetColor = targetColors[i % targetColors.length];

                    colors[i * 3] = currentColor.r * (1 - t) + targetColor.r * t;
                    colors[i * 3 + 1] = currentColor.g * (1 - t) + targetColor.g * t;
                    colors[i * 3 + 2] = currentColor.b * (1 - t) + targetColor.b * t;
                }

                this.particles.geometry.attributes.position.needsUpdate = true;
                this.particles.geometry.attributes.color.needsUpdate = true;
            }

            // ============================================
            // ANIMATION LOOP
            // ============================================

            animate() {
                requestAnimationFrame(() => this.animate());

                const currentTime = performance.now();
                this.deltaTime = Math.min((currentTime - this.lastTime) / 1000, 0.1);
                this.lastTime = currentTime;
                this.time += this.deltaTime;

                this.particles.material.uniforms.time.value = this.time;

                this.updateParticles();

                this.camera.position.set(0, 0, 10);
                this.camera.lookAt(0, 0, 0);

                this.renderer.render(this.scene, this.camera);
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Start
        window.addEventListener('DOMContentLoaded', () => {
            new QuantumHand();
        });
    </script>
</body>

</html>